InstallGlobalFunction(SRGroupsInfo,function(arg)
	local dir, fnam, G, list, listTemp, i, j, k, Gpos, lastNonZero, argFunctions, argMinimums, max;
	
	if IsEmpty(SRDegrees()) then
		Error("no data is available");
	fi;
	
	argFunctions:=["Degree","Depth/Level","Number","Projection","IsSubgroup","Size","MinimalGeneratingSet","Position/Index","IsAbelian"];
	argMinimums:=[2,1,1,1,1,,1,1];
	
	for i in [1,2] do
		if arg[i]<>0 then
			if not (IsInt(arg[i]) and (arg[i]>=argMinimums[i] or arg[i]=0)) then
				Error("input argument ",argFunctions[1],"=arg[1]=",arg[1]," must be an integer greater than or equal to ",argMinimums[i]);
			fi;
		fi;
	od;
	
	if arg[1]<>0 and arg[2]<>0 then
		argMinimums[6]:=arg[1]^arg[2];
		if not SRGroupsAvailable(arg[1],arg[2]) then
			Error("no data is available for degree ",arg[1]," and depth ",arg[2]);
		fi;
	elif arg[1]<>0 and arg[2]=0 then
		argMinimums[6]:=arg[1];
		if not arg[1] in SRDegrees() then
			Error("no data is available for degree ",arg[1]);
		fi;
	elif arg[1]=0 and arg[2]<>0 then
		argMinimums[6]:=2;
		for i in [1..Length(SRDegrees())] do
			if arg[2] in SRLevels(SRDegrees()[i]) then
				break;
			elif i=Length(SRDegrees()) and not arg[2] in SRLevels(SRDegrees()[i]) then
				Error("no data is available for depth ",arg[2]);
			fi;
		od;
	else
		argMinimums[6]:=2;
	fi;
	
	lastNonZero:=0;
	for i in [3..Length(arg)] do
		if i<9 then
			if arg[i]<0 or not IsInt(arg[i]) then
				Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be a non-negative integer");
			elif arg[i]<>0 then
				lastNonZero:=i;
			fi;
		fi;
		
		if i<9 and (i in [3,4,5] or not arg[i]>=argMinimums[i]) then
			if arg[i]<>0 then
				if i in [3,5] then
					if arg[1]<>0 and arg[2]<>0 then
						if not arg[i]<=NumberSRGroups(arg[1],arg[2]) then
							Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",NumberSRGroups(arg[1],arg[2]),"] or zero");
						fi;
					elif i=3 and arg[1]<>0 and arg[2]=0 then
						if not arg[i]<=NumberSRGroups(arg[1],Maximum(SRLevels(arg[1]))) then
							Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",NumberSRGroups(arg[1],Maximum(SRLevels(arg[1]))),"] or zero");
						fi;
					elif i=3 and arg[1]=0 and arg[2]<>0 then
						for j in [1..Length(SRDegrees())] do
							if arg[2] in SRLevels(SRDegrees()[j]) then
								max:=SRDegrees()[j];
							fi;
						od;
						if not arg[i]<=NumberSRGroups(max,arg[2]) then
							Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",NumberSRGroups(max,arg[2]),"] or zero");
						fi;
					elif i=3 then
						max:=0;
						for j in [1..Length(SRDegrees())] do
							for k in [1..Length(SRLevels(SRDegrees()[j]))] do
								if NumberSRGroups(SRDegrees()[j],SRLevels(SRDegrees()[j])[k])>max then
									max:=NumberSRGroups(SRDegrees()[j],SRLevels(SRDegrees()[j])[k]);
								fi;
							od;
						od;
						if not arg[i]<=max then
							Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",max,"] or zero");
						fi;
					fi;
				elif i=4 then
					if arg[1]<>0 and arg[2]<>0 then
						if SRGroupsAvailable(arg[1],arg[2]-1) then
							if not arg[i]<=NumberSRGroups(arg[1],arg[2]-1) then
								Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",NumberSRGroups(arg[1],arg[2]-1),"] or zero");
							fi;
						fi;
					elif arg[1]<>0 and arg[2]=0 then
						if Length(SRLevels(arg[1]))>=2 then
							for j in [2..Length(SRLevels(arg[1]))] do
								if SRLevels(arg[1])[j]-1=SRLevels(arg[1])[j-1] then
									max:=SRLevels(arg[1])[j]-1;
								fi;
							od;
						fi;
						if IsBound(max) then
							if not arg[i]<=NumberSRGroups(arg[1],max) then
								Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",NumberSRGroups(arg[1],max),"] or zero");
							fi;
						else
							Error("no data available containing two consecutive levels of degree ",arg[1]);
						fi;
					elif arg[1]=0 and arg[2]<>0 then
						for j in [1..Length(SRDegrees())] do
							if arg[2] in SRLevels(SRDegrees()[j]) and arg[2]-1 in SRLevels(SRDegrees()[j]) then
								max:=SRDegrees()[j];
							fi;
						od;
						if IsBound(max) then
							if not arg[i]<=NumberSRGroups(max,arg[2]) then
								Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",NumberSRGroups(max,arg[2]),"] or zero");
							fi;
						else
							Error("no data available containing level ",arg[i]," and level ",arg[i]-1," groups");
						fi;
					else
						max:=0;
						for j in [1..Length(SRDegrees())] do
							if Length(SRLevels(SRDegrees()[j]))>=2 then
								for k in [2..Length(SRLevels(SRDegrees()[j]))] do
									if SRLevels(SRDegrees()[j])[k]-1=SRLevels(SRDegrees()[j])[k-1] then
										if NumberSRGroups(SRDegrees()[j],SRLevels(SRDegrees()[j])[k-1])>max then
											max:=NumberSRGroups(SRDegrees()[j],SRLevels(SRDegrees()[j])[k-1]);
										fi;
									fi;
								od;
							fi;
						od;
						if max>0 then
							if not arg[i]<=max then
								Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [",argMinimums[i],"..",max,"] or zero");
							fi;
						else
							Error("no data available containing level ",arg[i]," and level ",arg[i]-1," groups");
						fi;
					fi;
				elif i=8 and not arg[i]<=4 then
					Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer in [1..4] or zero");
				else
					Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be an integer greater than or equal to ",argMinimums[i]);
				fi;
			fi;
		elif i=9 and not (IsBool(arg[i]) or arg[i]=0) then
			Error("input argument ",argFunctions[i],"=arg[",i,"]=",arg[i]," must be a boolean");
		fi;
	od;

	dir:= DirectoriesPackageLibrary( "SRGroups", "data" );
	if arg[1]<>0 and arg[2]<>0 then
		list:=[];
		listTemp:=GetSRData(arg[1],arg[2]);
		Append(list,listTemp);
	elif arg[1]=0 and arg[2]<>0 then
		list:=[];
		for i in [1..Length(SRDegrees())] do
			listTemp:=GetSRData(SRDegrees()[i],arg[2]);
			Append(list,listTemp);
		od;
	elif arg[1]<>0 and arg[2]=0 then
		list:=[];
		for i in [1..Length(SRLevels(arg[1]))] do
			listTemp:=GetSRData(arg[1],SRLevels(arg[1])[i]);
			Append(list,listTemp);
		od;
	else
		list:=[];
		for i in [1..Length(SRDegrees())] do
			for j in [1..Length(SRLevels(SRDegrees()[i]))] do
				listTemp:=GetSRData(SRDegrees()[i],SRLevels(SRDegrees()[i])[j]);
				Append(list,listTemp);
			od;
		od;
	fi;
	
	if Length(arg)>=9 and arg[9]<>0 then
		listTemp:=[];
		if arg[1]<>0 and arg[2]<>0 and arg[3]<>0 then
			Error("input arguments Number and IsAbelian are not compatible when a Degree and Depth have been selected");
		else
			for i in [1..Length(list)] do
				if IsAbelian(Group(list[i][1]))=arg[9] then
					Add(listTemp,list[i]);
				fi;
			od;
			list:=listTemp;
		fi;
	fi;
	
	if Length(arg)>=1 and (lastNonZero=2 or lastNonZero=1) then
		G:=list;
		return G;
	fi;
	
	if Length(arg)>=3 and arg[3]<>0 then
		if arg[1]<>0 and arg[2]<>0 then
			list:=list[arg[3]];
		else
			Gpos:=1;
			listTemp:=[];
			for i in [1..Length(list)] do
				if EndsWith(SplitString(list[i][2]," = ")[1],Concatenation(",",String(arg[3]),")")) then
					listTemp[Gpos]:=list[i];
					Gpos:=Gpos+1;
				fi;
			od;
			list:=listTemp;
		fi;
		if lastNonZero=3 then
			G:=list;
			return G;
		fi;
	fi;
	
	if Length(arg)>=4 and arg[3]=0 and arg[4]<>0 then
		Gpos:=1;
		listTemp:=[];
		for i in [1..Length(list)] do
			if EndsWith(SplitString(list[i][3]," = ")[1],Concatenation(",",String(arg[4]),")")) then
				listTemp[Gpos]:=list[i];;
				Gpos:=Gpos+1;
			fi;
		od;
		list:=listTemp;
		if lastNonZero=4 then
			G:=list;
			return G;
		fi;
	fi;
	
	if Length(arg)>=5 and arg[3]=0 and (not (arg[1]=0 or arg[2]=0)) and arg[5]<>0 then
		Gpos:=1;
		listTemp:=[];
		for i in [1..Length(list)] do
			if IsSubgroup(Group(list[arg[5]][1]),Group(list[i][1])) and (not i=arg[5]) then
				listTemp[Gpos]:=list[i];
				Gpos:=Gpos+1;
			fi;
		od;
		list:=listTemp;
		if lastNonZero=5 then
			G:=list;
			return G;
		fi;
	fi;
	
	if Length(arg)>=6 and arg[3]=0 and arg[7]=0 and arg[6]<>0 then
		listTemp:=[];
		for i in [1..Length(list)] do
			if Size(Group(list[i][1]))=arg[6] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if lastNonZero=6 then
			G:=list;
			return G;
		fi;
	fi;
	
	if Length(arg)>=7 and arg[3]=0 and arg[6]=0 and arg[7]<>0 then
		listTemp:=[];
		for i in [1..Length(list)] do
			if Length(MinimalGeneratingSet(Group(list[i][1])))=arg[7] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if lastNonZero=7 then
			G:=list;
			return G;
		fi;
	fi;

	if Length(arg)>=8 and arg[8]<>0 then
		listTemp:=[];
		if arg[1]<>0 and arg[2]<>0 and arg[3]<>0 then
			listTemp:=list[arg[8]];
		else
			for i in [1..Length(list)] do
				listTemp[i]:=list[i][arg[8]];
			od;
		fi;
		list:=listTemp;
		if lastNonZero=8 then
			G:=list;
			return G;
		fi;
	fi;

	if IsBound(G) then
		return G;
	else
		Error("no method exists for those arguments; check if they are conflicting");
	fi;
end);