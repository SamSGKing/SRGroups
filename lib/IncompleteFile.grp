# Input:: deg: degree of the tree (integer at least 2), lev: level of the tree (integer at least 1; if lev=1, then the unformatted "sr_deg_1.grp" file must already exist) (requires "sr_deg_lev+1.grp" file to exist)
# Output:: Formatted version of the file "sr_deg_lev.grp"
InstallGlobalFunction(FormatSRFile, function(deg,lev)
	local pr, fSingleGroup, fCumulative, numGroupsAbove, numProj, i, groupInfo, projBelow, prBelow, aboveCount, k, fNew, dirData, dirTempFiles,reEntry, reEntryCheck, fVariables, numGroups, gens, gensAbove, gensAboveTemp, currentGens, j, fGens, fGensAbove, groupNum;

	# 0. Create directories to be used (dirData: storage of final group files, dirTempFiles: storage of temporary files).
	dirData:=DirectoriesPackageLibrary("SRGroups", "data");
	dirTempFiles:=DirectoriesPackageLibrary("SRGroups", "data/temp_files");

	# 1. Create required filenames.
	fSingleGroup:=Filename(dirTempFiles[1],Concatenation("temp_",String(deg),"_",String(lev),"_indiv.grp"));
	fCumulative:=Filename(dirTempFiles[1],Concatenation("temp_",String(deg),"_",String(lev),"_full.grp"));
	fNew:=Filename(dirData[1],Concatenation("sr_",String(deg),"_",String(lev),".grp"));
	fVariables:=Filename(dirTempFiles[1],Concatenation("temp_",String(deg),"_",String(lev),"_format_var.grp"));

	# 2. Initialise required variables.
	if lev>1 then
		pr:=Projection(AutT(deg,lev));
	fi;
	prBelow:=Projection(AutT(deg,lev+1));
	groupInfo:=[]; # List of lists containing formatted group information
	# 2.1. Check if formatting has already been partially completed (re-entry condition). If so, read file "temp_deg_lev_format_var.grp" for previously bound variables. Otherwise, continue initialising variables.
	if IsExistingFile(fVariables) then
		reEntry:=true;
		reEntryCheck:=true;
		Read(fVariables);
		if IsExistingFile(fNew) then
			numGroups:=EvalString("varArg1");
			gens:=EvalString("varArg2");
			numProj:=EvalString("varArg3");
			numGroupsAbove:=EvalString("varArg4");
			aboveCount:=EvalString("varArg5");
			j:=EvalString("varArg6");
			UnbindVariables("varArg1","varArg2","varArg3","varArg4","varArg5","varArg6");
		else
			numGroups:=EvalString("varArg1");
			i:=EvalString("varArg2");
			gens:=EvalString("varArg3");
			numProj:=EvalString("varArg4");
			numGroupsAbove:=EvalString("varArg5");
			gensAbove:=EvalString("varArg6");
			UnbindVariables("varArg1","varArg2","varArg3","varArg4","varArg5","varArg6");
			if i>numGroups then
				aboveCount:=EvalString("varArg7");
				j:=EvalString("varArg8");
				UnbindVariables("varArg7","varArg8");
			fi;
		fi;
	else
		reEntry:=false;
		reEntryCheck:=false;
		numProj:=[];
		numGroups:=EvalString(SplitString(SplitString(SRGroup(deg,lev+1)[Length(SRGroup(deg,lev+1))][3],",")[3],")")[1]); # Number of groups on level lev (using file "sr_deg_lev+1.grp").
		numGroupsAbove:=0;
		aboveCount:=1;
		j:=1;
		i:=1;
	fi;
	# 2.2. Generate lists containing the same projections from lev+1 to lev, stored in projBelow[groupNum].
	projBelow:=[];
	for groupNum in [1..numGroups] do
		projBelow[groupNum]:=SRGroup(deg,lev+1,0,groupNum);
	od;

	# 3. Gather data to store in groupInfo. This has to be separated into the case where "sr_deg_lev.grp" (unformatted) exists and when it doesn't.
	if IsExistingFile(fNew) then
		# 3.1. Case when "sr_deg_lev.grp" exists. The following variables already exist upon re-entry, so this part can be skipped in this case.
		if not reEntry then
			# 3.1.1. Obtain generators of group (in correct order) on level lev, stored in gens. 
			gens:=[];
			for i in [1..numGroups] do
				gens[i]:=GeneratorsOfGroup(Image(prBelow,Group(projBelow[i][1][1]))); # Generators of the projected image of the first group from projBelow[i].
			od;
			# 3.1.2. Calculate the number of projections from lev to lev-1 for each group (cumulatively), stored in numProj.
			if lev>1 then
				numGroupsAbove:=EvalString(SplitString(SplitString(SRGroup(deg,lev)[Length(SRGroup(deg,lev))][3],",")[3],")")[1]); # Number of groups on level lev-1 (using file "sr_deg_lev.grp").
				for i in [1..numGroupsAbove] do
					if i>1 then
						numProj[i]:=numProj[i-1]+Length(SRGroup(deg,lev,0,i));
					else
						numProj[i]:=Length(SRGroup(deg,lev,0,i));
					fi;
				od;
			fi;
		fi;
	else
		# 3.2. Case when "sr_deg_lev.grp" does not exist.
		# First create required filenames. fGens stores the generators of each group on level lev in file "temp_deg_lev_gens.grp", fGensAbove stores the generators of each group on level lev-1 in file "temp_deg_lev-1_gens.grp".
		# Both of these are stored under the variable name gensTemp. fGensAbove is stored to be used in the next iteration (i.e. when lev=lev-1).
		fGens:=Filename(dirTempFiles[1],Concatenation("temp_",String(deg),"_",String(lev),"_gens.grp"));
		fGensAbove:=Filename(dirTempFiles[1],Concatenation("temp_",String(deg),"_",String(lev-1),"_gens.grp"));
		# 3.2.1. The following variables already exist upon re-entry.
		if not reEntry then
			# 3.2.1.1. currentGens stores a temporary generating set for a group, which is used to compare with generators on level lev-1 for unique groups. Initialise as trivial.
			currentGens:=[()]; 
			gens:=[];
			gensAbove:=[];
			# 3.2.1.2. If "temp_deg_lev_gens.grp" already exists (from previous iteration), then read the file to obtain variable gensTemp and set gens to this value. Otherwise, gens needs to be created from projections.
			if IsExistingFile(fGens) then
				Read(fGens);
				gens:=EvalString("gensTemp");
			else
				gens:=[];
			fi;
		fi;
		# 3.2.2. Loop to obtain the generators of groups on levels lev and lev-1, and the number of projections from lev to lev-1 for each group on level lev.
		while i<=numGroups do
			# 3.2.2.1. For each group projecting to a distinct group on lev from lev+1, calculate the unique generators.
			# Then, calculate the generators after projecting from each group on lev to lev-1 (not necessarily distinct).
			if not (IsExistingFile(fGens) and reEntry) then
				gens[i]:=GeneratorsOfGroup(Image(prBelow,Group(projBelow[i][1][1]))); # Generators of the projected image of the first group from projBelow[i].
			fi;
			gensAboveTemp:=GeneratorsOfGroup(Image(pr,Group(gens[i]))); # Generators of the projected image of the group on level lev generated by gens[i].
			# 3.2.2.2. Calculate the number of projections from lev to lev-1 for each group (cumulatively), stored in numProj.
			if Group(gensAboveTemp)=Group(currentGens) then
				# 3.2.2.2.1. If the generated group is not unique (always the case when i=1 since currentGens is initialised as trivial), currentGens stays the same and the number of identical groups in numProj[numGroupsAbove] is increased by 1.
				numProj[numGroupsAbove]:=numProj[numGroupsAbove]+1;
			else
				# 3.2.2.2.2. If the generated group is unique, increase numGroupsAbove by 1 and store the cumulative number of groups in numProj[numGroupsAbove].
				# Additionally, set currentGens and gensAbove[numGroupsAbove] to gensAboveTemp, and store gensAboveTemp in "temp_deg_lev-1_gens.grp" for use in the next iteration.
				numGroupsAbove:=numGroupsAbove+1;
				gensAbove[numGroupsAbove]:=gensAboveTemp;
				currentGens:=gensAbove[numGroupsAbove];
				if i>1 then
					numProj[numGroupsAbove]:=numProj[numGroupsAbove-1]+1;
					AppendTo(fGensAbove,",\n\t",gensAbove[numGroupsAbove]);
				else
					numProj[numGroupsAbove]:=1;
					PrintTo(fGensAbove,"BindGlobal(\"gensTemp\",\n[\n\t",gensAbove[numGroupsAbove]);
				fi;
			fi;
			# 3.2.2.3. Append final closing statement for gensTemp variable in "temp_deg_lev-1_gens.grp".
			if i=numGroups then
				AppendTo(fGensAbove,"\n]);");
			fi;
			i:=i+1;
			# 3.2.2.4. Save this point.
			PrintTo(fVariables,StringVariables(numGroups,i,gens,numProj,numGroupsAbove,gensAbove)); # Save-point
			# 3.2.2.5. Check and declare if re-entry was completed (by setting reEntry to false).
			if reEntry then
				reEntry:=false;
			fi;
		od;
	fi;

	# 4. Store and print formatted group information.
	while j<=numGroups do
		# 4.1. Create entries containing individual group information.
		groupInfo[j]:=[];
		groupInfo[j][1]:=gens[j];
		groupInfo[j][2]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(j),")\"");
		# 4.1.1. Index 3 must reflect the known groups each group on level lev projects to (using numProj[aboveCount]).
		if lev>1 then
			if j<=numProj[aboveCount] then
				groupInfo[j][3]:=Concatenation("\"SRGroup(",String(deg),",",String(lev-1),",",String(aboveCount),")\"");
			else
				aboveCount:=aboveCount+1;
				groupInfo[j][3]:=Concatenation("\"SRGroup(",String(deg),",",String(lev-1),",",String(aboveCount),")\"");
			fi;
		else
			groupInfo[j][3]:="\"emptyset\"";
		fi;
		# 4.2. Print all individual group information (in correct format) to "temp_deg_lev_indiv.grp".
		PrintTo(fSingleGroup, "\n\t", "[");
		AppendTo(fSingleGroup, "\n\t\t", groupInfo[j][1], ",");
		AppendTo(fSingleGroup, "\n\t\t", groupInfo[j][2], ",");
		AppendTo(fSingleGroup, "\n\t\t", groupInfo[j][3], ",");
		# 4.2.1. Index 4 must reflect the known groups each group on level lev extends to (using projBelow[j]).
		groupInfo[j][4]:=[];
		for k in [1..Length(projBelow[j])] do
			groupInfo[j][4][k]:=projBelow[j][k][2];
			if Length(projBelow[j])=1 then
				AppendTo(fSingleGroup,"\n\t\t", "[\"", groupInfo[j][4][k], "\"]\n\t]");
			elif k=1 then
				AppendTo(fSingleGroup, "\n\t\t", "[\"", groupInfo[j][4][k], "\",");
			elif k=Length(projBelow[j]) then
				AppendTo(fSingleGroup, "\n\t\t\"", groupInfo[j][4][k], "\"]\n\t]");
			else 
				AppendTo(fSingleGroup, "\n\t\t\"", groupInfo[j][4][k], "\",");
			fi;
		od;
		# 4.3. If fCumulative does not exist, it must be created and the first lines populated.
		if not IsExistingFile(fCumulative) then
		PrintTo(fCumulative, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev),"\",\n["));
		fi;
		# 4.4. If the very final group has been successfully formatted, then append the final line of fCumulative.
		# Otherwise, append a new line indicating another group entry will be added.
		if j=numGroups then
			AppendTo(fCumulative,StringFile(fSingleGroup),"\n]);");
		else
			AppendTo(fCumulative,StringFile(fSingleGroup),",\n");
		fi;
		j:=j+1;
		# 4.5. Save this point.
		if IsExistingFile(fNew) then
			PrintTo(fVariables,StringVariables(numGroups,gens,numProj,numGroupsAbove,aboveCount,j)); # Save-point (case 1)
		else
			PrintTo(fVariables,StringVariables(numGroups,i,gens,numProj,numGroupsAbove,gensAbove,aboveCount,j)); # Save-point (case 2)
		fi;
		# 4.6. Check and declare if re-entry was completed (by setting reEntry to false).
		if reEntry then
			reEntry:=false;
		fi;
	od;

	# 5. Remove "temp_deg_lev_gens.grp" file and gensTemp variable if required.
	if not IsExistingFile(fNew) then
		if IsExistingFile(fGens) then
			RemoveFile(fGens);
		fi;
		if IsBound(gensTemp) then
			MakeReadWriteGlobal("gensTemp");
			UnbindGlobal("gensTemp");
		fi;
	fi;

	# 6. Print all group information to final sr_deg_lev.grp file and remove other associated temporary files.
	PrintTo(fNew,StringFile(fCumulative));
	RemoveFile(fSingleGroup);
	RemoveFile(fCumulative);
	RemoveFile(fVariables);
	return;
end);