#
# SRGroups: Self-replicating groups of regular rooted trees.
#
# Routines
#

# arg[1]:=degree
# arg[2]:=level
# arg[3]:=number
# arg[4]:=groups with same projection (arg[3]=0 is required)
# arg[5]:=position (arg[3]=0 and arg[4]=0 is required)
InstallGlobalFunction(SRGroup,function(arg)
local dir, fnam, G, list, i, Gpos, temp;

dir:= DirectoriesPackageLibrary( "SRGroups", "data" );
if IsExistingFile(Filename( dir[1], Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"))) then
	fnam:=Filename( dir, Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"));
	Read(fnam);
else
	Print("These groups are not available (yet)!");
	return;
fi;

if (Length(arg)=3) and not (arg[3]=0) then
	G:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2]),"[",String(arg[3]),"]"));
elif (Length(arg)=2) or (Length(arg)=3 and arg[3]=0) then
	G:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
elif (Length(arg)=4) and (arg[3]=0) then
	list:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
	Gpos:=1;
	G:=[];
	for i in [1..Length(list)] do
		if EndsWith(list[i][3],Concatenation(",",String(arg[4]),")")) then
			G[Gpos]:=list[i];
			Gpos:=Gpos+1;
		fi;
	od;	
elif (Length(arg)=5) and ((arg[4]=0) and (arg[3]=0)) then
	list:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
		Gpos:=1;
		G:=[];
		temp:=arg[5];
		for i in [1..Length(list)] do
			G[Gpos]:=list[i][temp];
			Gpos:=Gpos+1;
		od;
else
	Print("No method exists!");
	return;
fi;

MakeReadWriteGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
UnbindGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
return G;
end);

InstallGlobalFunction(CheckSRProjections,function(arg)
local dir, fnam, list1, list2, pr, i, G1, G2, check;

check:=0;
list1:=SRGroup(arg[1],arg[2],0,0,1);
list2:=SRGroup(arg[1],arg[2],0,0,3);
pr:=Projection(AutT(arg[1],arg[2]));
for i in [1..Length(list1)] do
	G1:=Image(pr,Group(list1[i]));
	G2:=Group(EvalString(list2[i])[1]);
	if not G1=G2 then
		Print("SRGroup(",String(arg[1]),",",String(arg[2]),")[",String(i),"]\n");
		check:=check+1;
	fi;
od;

if check=0 then
	Print("All groups project correctly.");
else
	Print(check,"groups did not project corrrectly.");
fi;

return;
end);

InstallGlobalFunction(SRGroupFile, function(arg)
local fName, dir, k, i, j, list1, list2, list3, deg, lev, SRG, cmnt, n, fNameTemp, GroupList, initial, previous, temp,
tempFile, GroupList2, numberoflists, unsortedlist1, unsortedlist2, sortedlist, PrevPosList, N, M, Identicals, o , p,
sortingtemp, total, Vertices, I, J, fNameTemp2, PrevGroupList, newgrouplist, Prev, Post, m, fNameTemp3, fNameTemp4, fNameTemp5;

	dir:=DirectoriesPackageLibrary("SRGroups", "data");
	list1:=DirectoryContents(dir[1]);
	if arg[1]=0 or arg[1]=1 then
		k:=list1[Length(list1)];
		i:=SplitString(k, ".", "_");
		deg:=EvalString(list1[2])+1;
		fName:=Filename(dir[1], Concatenation(list1[1], "_", String(deg), "_", String(1), ".grp"));
		# Need to work out how to add all the self-replicating groups on level 1 =: A
		#AppendTo(fName, SRG);
	else 
		deg:=arg[1];
		#if an element of list begins with "sr_arg[1]_" then we are going to store it as our value of k. Each time we find another value in list that begins with the same string we will overwrite k as our list will be stored in an increasing sequence so naturally it will store the greatest value of k last. 
		i:=1;
		while i < Length(list1)+1 do
			if StartsWith(list1[i], Concatenation("sr_", String(deg))) then
				k:=list1[i];
			fi;
			i:=i+1;
		od;
		i:=SplitString(k, ".", "_");
		lev:=EvalString(i[3])+1;
		fName:=Filename(dir[1], Concatenation(i[1], "_", String(deg), "_", String(lev), ".grp"));
		list2:=[];
		fNameTemp:=Filename(dir[1], Concatenation("temp", "_", String(deg), "_", String(lev), ".grp"));
		initial:=1;
		if IsExistingFile(fNameTemp) then
			Read(fNameTemp);
			tempFile:=Filename(dir,"temp.grp");
			previous:=0;
			while previous=initial-1 do
				previous:=initial;
				PrintTo(tempFile,Concatenation("initial1:=",String(initial),";\n\nif IsBound(temp_",String(deg),"_",String(lev-1),"_",String(initial),"_proj) then\n\tinitial1:=initial1+1;\nfi;"));
				Read(tempFile);
				initial:=EvalString("initial1");
				if previous=initial-1 then
					MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(previous),"_proj"));
					UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(previous),"_proj"));
				fi;
				UnbindGlobal("initial1");
			od;
		fi;
		if initial<Length(SRGroup(deg,lev-1)) then
			for j in [initial..Length(SRGroup(deg,lev-1))] do
				GroupList:=ConjugacyClassRepsSelfReplicatingSubgroupsWithProjection(deg, lev, Group(SRGroup(deg, lev-1, j)[1]));
				if j=1 then
					AppendTo(fNameTemp,Concatenation("BindGlobal(\"temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj\",\n["));
				else
					AppendTo(fNameTemp,Concatenation("\n\nBindGlobal(\"temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj\",\n["));
				fi;
				for n in [1..Length(GroupList)] do
					list2[n]:=GeneratorsOfGroup(GroupList[n]);
					if n=Length(GroupList) then
						AppendTo(fNameTemp,Concatenation("\n\t",String(list2[n]),"\n]);"));
					else
						AppendTo(fNameTemp,Concatenation("\n\t",String(list2[n]),","));
					fi;
				od;
			od;
		fi;
		fNameTemp2:=Filename(dir[1],Concatenation("temp_,",String(deg),"_",String(lev),"_above_indiv.grp"));
		fNameTemp3:=Filename(dir[1],Concatenation("temp_,",String(deg),"_",String(lev),"_indiv.grp"));
		fNameTemp4:=Filename(dir[1],Concatenation("temp_,",String(deg),"_",String(lev),"_full.grp"));
		fNameTemp5:=Filename(dir[1],Concatenation("temp_,",String(deg),"_",String(lev),"_var.grp"));
		fNameTemp6:=Filename(dir[1],Concatenation("temp_,",String(deg),"_",String(lev),"_above.grp"));
		AppendTo(fNameTemp4, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev),"\",\n["));
		AppendTo(fNameTemp6, "BindGlobal(\"sr_",String(deg),"_",String(lev-1),"\",\n[");
		GroupList2:=[];
		if lev=1 then
			GroupList2:=GroupList;
		elif lev=2 then
			numberoflists:=1;
		else 
			numberoflists:=Length(SRGroup(deg,lev-2));
		fi;
		if lev>1 then
			Read(fNameTemp);
			if IsExistingFile(fNameTemp4) and IsExistingFile(fNameTemp5) then
				check:=true;
				Read(fNameTemp5);
			elif IsExistingFile(fNameTemp4) or IsExistingFile(fNameTemp5) then
				Print("We do not have enough files to continue!");
				return;
			else
				check:=false;
				unsortedlist1:=[];
				for j in [1..Length(SRGroup(deg,lev-1))] do
					unsortedlist1[j]:=Length(EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj")));
				od;
				unsortedlist2:=[];
				sortedlist:=[];
				PrevPosList:=[];
				PrevGroupList:=SRGroup(deg,lev-1);
				newgrouplist:=[];
				Vertices:=Length(PrevGroupList);
				total:=0;
				N:=1;
				M:=1;
				I:=1;
				J:=1;
				initialj:=1;
				initialn:=1;
			fi;
			for j in [initialj..numberoflists] do
				if not check then
					unsortedlist2[j]:=[];
					sortedlist[j]:=[];
					PrevPosList[j]:=[];
					newgrouplist[j]:=[];
					if j>1 then
						total:=total+Length(SRGroup(deg,lev-1,0,j-1));
					fi;
				fi;
				for n in [initialn..Length(SRGroup(deg,lev-1,0,j))] do
					unsortedlist2[j][n]:=unsortedlist1[N];
					N:=N+1;
				od;
				n:=1;
				sortedlist[j]:=SortedList(unsortedlist2[j]);
				while n<=Length(SRGroup(deg,lev-1,0,j)) do
					Identicals:=Positions(unsortedlist2[j],sortedlist[j][n]);
					for o in [1..Length(Identicals)] do
						PrevPosList[j][n]:=Identicals[o];
						if re-entry then
							initialp:=p;
						fi;
						for p in [1..sortedlist[j][n]] do
							GroupList2[M]:=[];
							GroupList2[M][1]:=EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"))[p];
							GroupList2[M][2]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(M),")\"");
							GroupList2[M][3]:=Concatenation("\"SRGroup(",String(deg),",",String(lev-1),",",String(total+n),")\"");
							GroupList2[M][4]:="[\"the classes it extends to\"]";
							if not M=1 then
								PrintTo(fNameTemp3,Concatenation("\n\n\t[\n\t\t",String(GroupList2[M][1])));
							else
								PrintTo(fNameTemp3,Concatenation("\n\t[\n\t\t",String(GroupList2[M][1])));
							fi;
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][2]);
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][3]);
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][4],"\n\t],");
							AppendTo(fNameTemp4,StringFile(fNameTemp3));
							PrintTo(fNameTemp5,EnString());
							M:=M+1;
						od;
						if re-entry then
							re-entry:=false;
						fi;
						newgrouplist[j][n]:=PrevGroupList[total+PrevPosList[j][n]];
						newgrouplist[j][n][2]:=String(Concatenation("\"SRGroup(", String(deg), ",", String(lev-1), ",", String(total+n), ")\""));
						PrintTo(fNameTemp2, "\n\t", "[");
						AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][1], ",");
						AppendTo(fNameTemp2, "\n\t\t", "", newgrouplist[j][n][2], ",");
						AppendTo(fNameTemp2, "\n\t\t", "\"", newgrouplist[j][n][3], "\",");
						for m in [1..sortedlist[j][n]] do
							newgrouplist[j][n][4]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(I),")\"");
							if sortedlist[j][n]=1 then
								AppendTo(fNameTemp2,"\n\t\t", "[", newgrouplist[j][n][4], "]\n\t]");
							elif m=1 then
								AppendTo(fNameTemp2, "\n\t\t", "[", newgrouplist[j][n][4], ",");
							elif m=sortedlist[j][n] then
								AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][4], "]\n\t]");
							else 
								AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][4], ",");
							fi;
							I:=I+1;
						od;
						Vertices:=Vertices-1;
						if Vertices = 0 then
							AppendTo(fNameTemp6,StringFile(fNameTemp2),"\n]);");
						else
							AppendTo(fNameTemp6,StringFile(fNameTemp2),",\n");
						fi;
						PrintTo(fNameTemp5,EnString());
						MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"));
						UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"));
						n:=n+1;
					od;
				od;
			od;
		fi;
		AppendTo(fName,"\n]);");
		#RemoveFile(fNameTemp);
		#RemoveFile(tempFile);
	fi;
return;
end);

InstallGlobalFunction(EnString, function(total, unsortedlist1, unsortedlist2, j, m, n, p, I, J, M, N, PrevPosList)

Superstring:=Concatenation("total:=", String(total), ";\n", "unsortedlist1:=",String(unsortedlist1),";\n", "unsortedlist2:=", String(unsortedlist2), ";\n", "j:=", String(j), ";\n", "m:=", String(m), ";\n", "n:=", String(n), ";\n", "p:=", String(p), ";\n", "I:=", String(I), ";\n", "J:=", String(J), ";\n", "M:=", String(M), ";\n", "N:=", String(N), ";\n", "PrevPosList:=", String(PrevPosList));

return Superstring;
end);