#
# SRGroups: Self-replicating groups of regular rooted trees.
#
# Routines
#

# arg[1]:=degree
# arg[2]:=level
# arg[3]:=number
# arg[4]:=groups with same projection (arg[3]=0 is required)
# arg[5]:=position (arg[3]=0 and arg[4]=0 is required)
InstallGlobalFunction(SRGroup,function(arg)
local dir, fnam, G, list, i, Gpos, temp;

dir:= DirectoriesPackageLibrary( "SRGroups", "data" );
if IsExistingFile(Filename( dir[1], Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"))) then
	fnam:=Filename( dir, Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"));
	Read(fnam);
else
	Print("These groups are not available (yet)!");
	return;
fi;

if (Length(arg)=3) and not (arg[3]=0) then
	G:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2]),"[",String(arg[3]),"]"));
elif (Length(arg)=2) or (Length(arg)=3 and arg[3]=0) then
	G:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
elif (Length(arg)=4) and (arg[3]=0) then
	list:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
	Gpos:=1;
	G:=[];
	for i in [1..Length(list)] do
		if EndsWith(list[i][3],Concatenation(",",String(arg[4]),")")) then
			G[Gpos]:=list[i];
			Gpos:=Gpos+1;
		fi;
	od;	
elif (Length(arg)=5) and ((arg[4]=0) and (arg[3]=0)) then
	list:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
		Gpos:=1;
		G:=[];
		temp:=arg[5];
		for i in [1..Length(list)] do
			G[Gpos]:=list[i][temp];
			Gpos:=Gpos+1;
		od;
else
	Print("No method exists!");
	return;
fi;

MakeReadWriteGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
UnbindGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
return G;
end);

InstallGlobalFunction(CheckSRProjections,function(arg)
local dir, fnam, list1, list2, pr, i, G1, G2, check;

check:=0;
list1:=SRGroup(arg[1],arg[2],0,0,1);
list2:=SRGroup(arg[1],arg[2],0,0,3);
pr:=Projection(AutT(arg[1],arg[2]));
for i in [1..Length(list1)] do
	G1:=Image(pr,Group(list1[i]));
	G2:=Group(EvalString(list2[i])[1]);
	if not G1=G2 then
		Print("SRGroup(",String(arg[1]),",",String(arg[2]),")[",String(i),"]\n");
		check:=check+1;
	fi;
od;

if check=0 then
	Print("All groups project correctly.");
else
	Print(check,"groups did not project corrrectly.");
fi;

return;
end);

InstallGlobalFunction(SRGroupFile, function(arg)
local fName, dir, k, i, j, list1, list2, list3, deg, lev, SRG, cmnt, n, fNameTemp, GroupList, initial, previous, temp,
tempFile, GroupList2, numberoflists, unsortedlist1, unsortedlist2, sortedlist, PrevPosList, N, M, Identicals, o , p,
sortingtemp, total, Vertices, I, J, fNameTemp2, PrevGroupList, newgrouplist, Prev, Post, m, fNameTemp3, fNameTemp4, fNameTemp5,
fNameTemp6, reEntry, initialo, initialj, totaltemp, kk, totalsrs, reEntrychecker, jj, listOfGroups, x, y, z, levelOneLists, prePosList, sortedList1, unsortedList1, unsortedList2, repeats;

	dir:=DirectoriesPackageLibrary("SRGroups", "data");
	list1:=DirectoryContents(dir[1]);
	if arg[1]=0 or arg[1]=1 then
		totalsrs:=0;
		for k in [1..Length(list1)] do
			if StartsWith(list1[k],"sr_") then
				totalsrs:=totalsrs+1;
			fi;
		od;
		k:=list1[totalsrs];
		i:=SplitString(k, ".", "_");
		deg:=EvalString(i[2])+1;
		fName:=Filename(dir[1], Concatenation(i[1], "_", String(deg), "_1.grp"));
		fNameTemp3:=Filename(dir[1],Concatenation("temp_",String(deg),"_1_indiv.grp"));
		fNameTemp4:=Filename(dir[1],Concatenation("temp_",String(deg),"_1_full.grp"));
		fNameTemp5:=Filename(dir[1],Concatenation("temp_",String(deg),"_1_var.grp"));
		GroupList:=[];
		initialj:=1;
		if IsExistingFile(fNameTemp4) and IsExistingFile(fNameTemp5) then
				reEntry:=true;
				reEntrychecker:=true;
				Read(fNameTemp5);
				initialj:=EvalString("varArg1");
		else
			reEntry:=false;
			reEntrychecker:=false;
		fi;
		for j in [initialj..NrTransitiveGroups(deg)] do
			GroupList[j]:=[];
			GroupList[j][1]:=TRANSGrp(deg,j);
			Remove(GroupList[j][1],Length(GroupList[j][1]));
			GroupList[j][2]:=Concatenation("\"SRGroup(",String(deg),",1,",String(j),")\"");
			GroupList[j][3]:="\"emptyset\"";
			GroupList[j][4]:="[\"the classes it extends to\"]";
			if not j=1 then
				PrintTo(fNameTemp3,Concatenation("\n\n\t[\n\t\t",String(GroupList[j][1])));
			else
				PrintTo(fNameTemp3,Concatenation("\n\t[\n\t\t",String(GroupList[j][1])));
			fi;
			AppendTo(fNameTemp3,",\n\t\t",GroupList[j][2]);
			AppendTo(fNameTemp3,",\n\t\t",GroupList[j][3]);
			if not j=NrTransitiveGroups(deg) then
				AppendTo(fNameTemp3,",\n\t\t",GroupList[j][4],"\n\t],");
			else
				AppendTo(fNameTemp3,",\n\t\t",GroupList[j][4],"\n\t]");
			fi;
			if not IsExistingFile(fNameTemp4) then
				PrintTo(fNameTemp4, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level 1 ##\n\nBindGlobal(\"sr_",String(deg),"_1\",\n["));
			fi;
			AppendTo(fNameTemp4,StringFile(fNameTemp3));
			PrintTo(fNameTemp5,EnString(j));
		od;
		AppendTo(fNameTemp4,"\n]);");
		PrintTo(fName, StringFile(fNameTemp4));
	else 
		deg:=arg[1];
		#if an element of list begins with "sr_arg[1]_" then we are going to store it as our value of k. Each time we find another value in list that begins with the same string we will overwrite k as our list will be stored in an increasing sequence so naturally it will store the greatest value of k last. 
		i:=1;
		while i < Length(list1)+1 do
			if StartsWith(list1[i], Concatenation("sr_", String(deg))) then
				k:=list1[i];
			fi;
			i:=i+1;
		od;
		i:=SplitString(k, ".", "_");
		lev:=EvalString(i[3])+1;
		fName:=Filename(dir[1], Concatenation(i[1], "_", String(deg), "_", String(lev), ".grp"));
		list2:=[];
		fNameTemp:=Filename(dir[1], Concatenation("temp", "_", String(deg), "_", String(lev), ".grp"));
		initial:=1;
		if IsExistingFile(fNameTemp) then
			Read(fNameTemp);
			tempFile:=Filename(dir[1],Concatenation("temp_",String(deg),"_",String(lev),"_check.grp"));
			previous:=0;
			while previous=initial-1 do
				previous:=initial;
				PrintTo(tempFile,Concatenation("initial1:=",String(initial),";\n\nif IsBound(temp_",String(deg),"_",String(lev-1),"_",String(initial),"_proj) then\n\tinitial1:=initial1+1;\nfi;"));
				Read(tempFile);
				initial:=EvalString("initial1");
				if previous=initial-1 then
					MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(previous),"_proj"));
					UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(previous),"_proj"));
				fi;
				UnbindGlobal("initial1");
			od;
		fi;
		if initial<Length(SRGroup(deg,lev-1)) then
			for j in [initial..Length(SRGroup(deg,lev-1))] do
				GroupList:=ConjugacyClassRepsSelfReplicatingSubgroupsWithProjection(deg, lev, Group(SRGroup(deg, lev-1, j)[1]));
				if j=1 then
					AppendTo(fNameTemp,Concatenation("BindGlobal(\"temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj\",\n["));
				else
					AppendTo(fNameTemp,Concatenation("\n\nBindGlobal(\"temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj\",\n["));
				fi;
				for n in [1..Length(GroupList)] do
					list2[n]:=GeneratorsOfGroup(GroupList[n]);
					if n=Length(GroupList) then
						AppendTo(fNameTemp,Concatenation("\n\t",String(list2[n]),"\n]);"));
					else
						AppendTo(fNameTemp,Concatenation("\n\t",String(list2[n]),","));
					fi;
				od;
			od;
		fi;
		fNameTemp2:=Filename(dir[1],Concatenation("temp_",String(deg),"_",String(lev),"_above_indiv.grp"));
		fNameTemp3:=Filename(dir[1],Concatenation("temp_",String(deg),"_",String(lev),"_indiv.grp"));
		fNameTemp4:=Filename(dir[1],Concatenation("temp_",String(deg),"_",String(lev),"_full.grp"));
		fNameTemp5:=Filename(dir[1],Concatenation("temp_",String(deg),"_",String(lev),"_var.grp"));
		fNameTemp6:=Filename(dir[1],Concatenation("temp_",String(deg),"_",String(lev),"_above.grp"));
		GroupList2:=[];
		if lev=1 then
			GroupList2:=GroupList;
		elif lev=2 then
			Read(fNameTemp);
			unsortedList1:=[];
			unsortedList2:=[];
			sortedList1:=[];
			prePosList:=[];
			levelOneLists:=Length(SRGroup(deg, lev-1));	
			for x in [1..levelOneLists] do
				unsortedList1[x]:=[];
				sortedList1[x]:=[];
				prePosList[x]:=[];
				for y in [1..Length(SRGroup(deg,lev,0,x))] do
					unsortedList1[x][y]:=Length(SRGroup(deg,lev,0,x)[y][4]);
				od;
				unsortedList2[x]:=Length(unsortedList1[x]);
				sortedList1[x]:=Length(unsortedList1[x]);
			od;
			StableSort(sortedList1);
			y:=1;
			while y<=Length(unsortedList2) do
				repeats:=Positions(unsortedList2, sortedList1[y]);
				for z in [1..Length(repeats)] do
					prePosList[y]:=repeats[z];
					y:=y+1;
				od;
			od;
			listOfGroups:=[];
			for x in [1..levelOneLists] do
				listOfGroups[x]:=[];
				listOfGroups[x][1]:= EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(x),"_proj"));
				listOfGroups[x][2]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(x),")\"");
				listOfGroups[x][3]:=Concatenation("\"SRGroup(",String(deg),",",String(lev-1),",",String(x+lev-1),")\"");
				listOfGroups[x][4]:="[\"the classes it extends to\"]";
			od;
		else 
			numberoflists:=Length(SRGroup(deg,lev-2));
		fi;
		if lev>2 then
			Read(fNameTemp);
			if IsExistingFile(fNameTemp4) and IsExistingFile(fNameTemp5) then
				reEntry:=true;
				reEntrychecker:=true;
				Read(fNameTemp5);
				initialj:=EvalString("varArg1");
				initialo:=EvalString("varArg2");
				newgrouplist:=[];
				sortedlist:=EvalString("varArg3");
				total:=EvalString("varArg4");
				unsortedlist1:=EvalString("varArg5");
				unsortedlist2:=EvalString("varArg6");
				n:=EvalString("varArg7");
				p:=EvalString("varArg8");
				I:=EvalString("varArg9");
				M:=EvalString("varArg10");
				N:=EvalString("varArg11");
				Identicals:=EvalString("varArg12");
				PrevGroupList:=SRGroup(deg,lev-1);
				PrevPosList:=EvalString("varArg13");
				Vertices:=EvalString("varArg14");
				totaltemp:=0;
				for j in [1..initialj] do
					if j=initialj then
						for k in [1..n-1] do
							MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][k]),"_proj"));
							UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][k]),"_proj"));
						od;
					else
						if j>1 then
							for kk in [1..j-1] do
								totaltemp:=totaltemp+Length(unsortedlist2[kk]);
							od;
						fi;
						for k in [1..Length(unsortedlist2[j])] do
							MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(totaltemp+PrevPosList[j][k]),"_proj"));
							UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(totaltemp+PrevPosList[j][k]),"_proj"));
						od;
					fi;
				od;
			else
				reEntry:=false;
				reEntrychecker:=false;
				unsortedlist1:=[];
				for j in [1..Length(SRGroup(deg,lev-1))] do
					unsortedlist1[j]:=Length(EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj")));
				od;
				unsortedlist2:=[];
				sortedlist:=[];
				PrevPosList:=[];
				PrevGroupList:=SRGroup(deg,lev-1);
				newgrouplist:=[];
				Vertices:=Length(PrevGroupList);
				total:=0;
				N:=1;
				M:=1;
				I:=1;
				J:=1;
				initialj:=1;
				initialo:=1;
			fi;
			for j in [initialj..numberoflists] do
				newgrouplist[j]:=[];
				if not reEntry then
					unsortedlist2[j]:=[];
					sortedlist[j]:=[];
					PrevPosList[j]:=[];
					if j>1 then
						total:=total+Length(SRGroup(deg,lev-1,0,j-1));
					fi;
					for n in [1..Length(SRGroup(deg,lev-1,0,j))] do
						unsortedlist2[j][n]:=unsortedlist1[N];
						N:=N+1;
					od;
					n:=1;
					sortedlist[j]:=SortedList(unsortedlist2[j]);
				fi;
				while n<=Length(SRGroup(deg,lev-1,0,j)) do
					if not reEntry then
						Identicals:=Positions(unsortedlist2[j],sortedlist[j][n]);
					fi;
					for o in [initialo..Length(Identicals)] do
						if not reEntry then
							PrevPosList[j][n]:=Identicals[o];
							p:=1;
						fi;
						while p<=sortedlist[j][n] do
							GroupList2[M]:=[];
							GroupList2[M][1]:=EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"))[p];
							GroupList2[M][2]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(M),")\"");
							GroupList2[M][3]:=Concatenation("\"SRGroup(",String(deg),",",String(lev-1),",",String(total+n),")\"");
							GroupList2[M][4]:="[\"the classes it extends to\"]";
							if not M=1 then
								PrintTo(fNameTemp3,Concatenation("\n\n\t[\n\t\t",String(GroupList2[M][1])));
							else
								PrintTo(fNameTemp3,Concatenation("\n\t[\n\t\t",String(GroupList2[M][1])));
							fi;
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][2]);
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][3]);
							if not M=Sum(unsortedlist1) then
								AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][4],"\n\t],");
							else
								AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][4],"\n\t]");
							fi;
							if not IsExistingFile(fNameTemp4) then
								PrintTo(fNameTemp4, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev),"\",\n["));
							fi;
							AppendTo(fNameTemp4,StringFile(fNameTemp3));
							PrintTo(fNameTemp5,EnString(j, o, sortedlist, total, unsortedlist1, unsortedlist2, n, p, I, M, N, Identicals, PrevPosList, Vertices));
							if reEntry then
								reEntry:=false;
								initialo:=1;
							fi;
							p:=p+1;
							M:=M+1;
						od;
						if not I=M then
							if not reEntry then
								newgrouplist[j][n]:=PrevGroupList[total+PrevPosList[j][n]];
							fi;
							newgrouplist[j][n][2]:=String(Concatenation("\"SRGroup(", String(deg), ",", String(lev-1), ",", String(total+n), ")\""));
							PrintTo(fNameTemp2, "\n\t", "[");
							AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][1], ",");
							AppendTo(fNameTemp2, "\n\t\t", "", newgrouplist[j][n][2], ",");
							AppendTo(fNameTemp2, "\n\t\t", "\"", newgrouplist[j][n][3], "\",");
							for m in [1..sortedlist[j][n]] do
								newgrouplist[j][n][4]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(I),")\"");
								if sortedlist[j][n]=1 then
									AppendTo(fNameTemp2,"\n\t\t", "[", newgrouplist[j][n][4], "]\n\t]");
								elif m=1 then
									AppendTo(fNameTemp2, "\n\t\t", "[", newgrouplist[j][n][4], ",");
								elif m=sortedlist[j][n] then
									AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][4], "]\n\t]");
								else 
									AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][4], ",");
								fi;
								I:=I+1;
							od;
							MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"));
							UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"));
							Vertices:=Vertices-1;
							if not IsExistingFile(fNameTemp6) then
								PrintTo(fNameTemp6, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev-1),"\",\n["));
							fi;
							if Vertices = 0 then
								AppendTo(fNameTemp6,StringFile(fNameTemp2),"\n]);");
							else
								AppendTo(fNameTemp6,StringFile(fNameTemp2),",\n");
							fi;
							PrintTo(fNameTemp5,EnString(j, o, sortedlist, total, unsortedlist1, unsortedlist2, n, p, I, M, N, Identicals, PrevPosList, Vertices));
							if reEntry then
								reEntry:=false;
								initialo:=1;
							fi;
						fi;
						if reEntry then
							reEntry:=false;
							initialo:=1;
						fi;
						n:=n+1;
					od;
				od;
			od;
		fi;
		if reEntrychecker then
			Unleash("varArg1", "varArg2", "varArg3", "varArg4", "varArg5", "varArg6", "varArg7", "varArg8", "varArg9", "varArg10", "varArg11", "varArg12", "varArg13", "varArg14");
		fi;
		AppendTo(fNameTemp4,"\n]);");
		AppendTo(fName,StringFile(fNameTemp4));
		#RemoveFile(fNameTemp);
		#RemoveFile(tempFile);
	fi;
return;
end);

InstallGlobalFunction(EnString, function(arg)
local Superstring, i;

for i in [1..Length(arg)] do
	if i=1 then
		Superstring:=Concatenation("varArg",String(i),":=",String(arg[i]),";");
	else
		Superstring:=Concatenation(Superstring,"\nvarArg",String(i),":=",String(arg[i]),";");
	fi;
od;

return Superstring;
end);

InstallGlobalFunction(Unleash, function(arg)
local k;

for k in [1..Length(arg)] do
	UnbindGlobal(arg[k]);
od;
end);