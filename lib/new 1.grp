InstallGlobalFunction(GetSRMaximums,function(arg)
	local deg, lev, max, maxAbove, errorString, i;
	
	if arg[1][1]<>0 and arg[2][1]<>0 then
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			for deg in arg[1] do
				for lev in arg[2] do
					if SRGroupsAvailable(deg,lev) then
						if IsBound(max) then
							if max<NumberSRGroups(deg,lev) then max:=NumberSRGroups(deg,lev); fi;
						else
							max:=NumberSRGroups(deg,lev);
						fi;
					fi;
				od;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			for deg in arg[1] do
				for lev in arg[2] do
					if SRGroupsAvailable(deg,lev) and SRGroupsAvailable(deg,lev-1) then
						if IsBound(maxAbove) then
							if maxAbove<NumberSRGroups(deg,lev-1) then maxAbove:=NumberSRGroups(deg,lev-1); fi;
						else
							maxAbove:=NumberSRGroups(deg,lev-1);
						fi;
					fi;
				od;
			od;
			if not IsBound(maxAbove) then
				Error("no data available containing two consecutive levels of degree ",String(arg[1])," and level ",String(arg[2])," groups");
			fi;
		else
			maxAbove:=false;
		fi;
	elif arg[1][1]<>0 and arg[2][1]=0 then
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			for deg in arg[1] do
				if IsBound(max) then
					if max<NumberSRGroups(deg,Maximum(SRLevels(deg))) then max:=NumberSRGroups(deg,Maximum(SRLevels(deg))); fi;
				else
					max:=NumberSRGroups(deg,Maximum(SRLevels(deg)));
				fi;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			for deg in arg[1] do
				if Length(SRLevels(deg))>=2 then
					for i in [2..Length(SRLevels(deg))] do
						if SRLevels(deg)[i]-1=SRLevels(deg)[i-1] then
							if IsBound(maxAbove) then
								if maxAbove<NumberSRGroups(deg,SRLevels(deg)[i-1]) then maxAbove:=NumberSRGroups(deg,SRLevels(deg)[i-1]); fi;
							else
								maxAbove:=NumberSRGroups(deg,SRLevels(deg)[i-1]);
							fi;
						fi;
					od;
				fi;
			od;
			if not IsBound(maxAbove) then
				Error("no data available containing two consecutive levels of degree ",String(arg[1]));
			fi;
		else
			maxAbove:=false;
		fi;
	elif arg[1][1]=0 and arg[2][1]<>0 then
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			for deg in SRDegrees() do
				for lev in arg[2] do
					if lev in SRLevels(deg) then
						if IsBound(max) then
							if max<NumberSRGroups(deg,lev) then max:=NumberSRGroups(deg,lev); fi;
						else
							max:=NumberSRGroups(deg,lev);
						fi;
					fi;
				od;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			for deg in SRDegrees() do
				for lev in arg[2] do
					if lev in SRLevels(deg) and lev-1 in SRLevels(deg) then
						if IsBound(maxAbove) then
							if maxAbove<NumberSRGroups(deg,lev-1) then maxAbove:=NumberSRGroups(deg,lev-1); fi;
						else
							maxAbove:=NumberSRGroups(deg,lev-1);
						fi;
					fi;
				od;
			od;
			if not IsBound(maxAbove) then
				Error("no data available containing level ",String(arg[1])," and level ",String(arg[1]-1)," groups");
			fi;
		else
			maxAbove:=false;
		fi;
	else
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			max:=1;
			for deg in SRDegrees() do
				for lev in SRLevels(deg) do
					if NumberSRGroups(deg,lev)>max then
						max:=NumberSRGroups(deg,lev);
					fi;
				od;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			maxAbove:=0;
			for deg in SRDegrees() do
				if Length(SRLevels(deg))>=2 then
					for i in [2..Length(SRLevels(deg))] do
						if SRLevels(deg)[i]-1=SRLevels(deg)[i-1] then
							if NumberSRGroups(deg,SRLevels(deg)[i-1])>maxAbove then
								maxAbove:=NumberSRGroups(deg,SRLevels(deg)[i-1]);
							fi;
						fi;
					od;
				fi;
			od;
			if maxAbove=0 then
				Error("no data available containing two consecutive levels");
			fi;
		else
			maxAbove:=false;
		fi;
	fi;
	
	return [max,maxAbove];
end);

InstallGlobalFunction(CheckSRGroupsInputs,function(arg)
	local deg, lev, newDegs, newLevs, cont, errorString, i, j, k, argMinimums, argFunctions, degs, levs, max;
	
	if arg[1]=true then
		argMinimums:=arg[2];
		argFunctions:=arg[3];
		degs:=arg[4];
		levs:=arg[5];
		for deg in degs do
			if deg<>0 then
				if not (IsInt(deg) and (deg>=argMinimums[1] or deg=0)) then
					Error("input argument ",argFunctions[1],"=",deg," in arg[1] must be an integer greater than or equal to ", argMinimums[1]," or zero");
				fi;
			fi;
		od;
		
		for lev in levs do
			if lev<>0 then
				if not (IsInt(lev) and (lev>=argMinimums[2] or lev=0)) then
					if argMinimums[2]=2 then
						Error("input argument ",argFunctions[2],"=",lev," in arg[2] must be an integer greater than or equal to ", argMinimums[2]," or zero when the ",argFunctions[5]," argument is being used");
					else
						Error("input argument ",argFunctions[2],"=",lev," in arg[2] must be an integer greater than or equal to ", argMinimums[2]," or zero");
					fi;
				fi;
			fi;
		od;
		
		cont:=false;
		newDegs:=[];
		newLevs:=[];
		for deg in degs do
			for lev in levs do
				if deg<>0 and lev<>0 then
					if IsBound(argMinimums[6]) then
						if deg^lev<argMinimums[6] then argMinimums[6]:=deg^lev; fi;
					else
						argMinimums[6]:=deg^lev;
					fi;
					if SRGroupsAvailable(deg,lev) then
						cont:=true;
						if not deg in newDegs then Add(newDegs,deg); fi;
						if not lev in newLevs then Add(newLevs,lev); fi;
					fi;
				elif deg<>0 and lev=0 then
					if IsBound(argMinimums[6]) then
						if deg<argMinimums[6] then argMinimums[6]:=deg; fi;
					else
						argMinimums[6]:=deg;
					fi;
					if deg in SRDegrees() then
						Add(newDegs,deg);
						cont:=true;
					fi;
				elif deg=0 and lev<>0 then
					if not IsBound(argMinimums[6]) then argMinimums[6]:=2; fi;
					for i in [1..Length(SRDegrees())] do
						if lev in SRLevels(SRDegrees()[i]) then
							Add(newLevs,lev);
							cont:=true;
							break;
						fi;
					od;
				else
					cont:=true;
					argMinimums[6]:=2;
				fi;
			od;
		od;
		
		if cont then
			StableSort(newDegs);
			StableSort(newLevs);
			if degs[1]<>0 and levs[1]<>0 then
				return [cont,argMinimums,newDegs,newLevs];
			elif degs[1]<>0 and levs[1]=0 then
				return [cont,argMinimums,newDegs];
			elif degs[1]=0 and levs[1]<>0 then
				return [cont,argMinimums,newLevs];
			else
				return [cont,argMinimums];
			fi;
		else
			if degs[1]<>0 and levs[1]<>0 then
				Error("no data containing degree ",String(degs)," and level ",String(levs)," is available");
			elif degs[1]<>0 and levs[1]=0 then
				Error("no data containing degree ",String(degs)," is available");
			elif degs[1]=0 and levs[1]<>0 then
				Error("no data containing level ",String(levs)," is available");
			fi;
		fi;
	else
		i:=arg[1];
		argMinimums:=arg[3];
		argFunctions:=arg[4];
		degs:=arg[5];
		levs:=arg[6];
		if i in [3,4,5] then
			max:=arg[7];
		fi;
		arg:=arg[2];
		
		if i<9 then
			if arg<>0 then
				if i in [3,4,5] or not arg>=argMinimums[i] then
					if i in [3,5] then
						if degs[1]<>0 and levs[1]<>0 then
							if arg<=max then
								return true;
							else
								errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer in [",String(argMinimums[i]),"..",String(max),"] or zero");
							fi;
						elif i=3 then
							if arg<=max then
								return true;
							else
								errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer in [",String(argMinimums[i]),"..",String(max),"] or zero");
							fi;
						else
							errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be selected with a degree and depth");
						fi;
					elif i=4 then
						if arg<=max then
							return true;
						else
							errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer in [",String(argMinimums[i]),"..",String(max),"] or zero");
						fi;
					elif i=8 and not arg<=4 then
						errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer in [1..4] or zero");
					else
						errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer greater than or equal to ",String(argMinimums[i])," or zero");
					fi;
				else
					return true;
				fi;
			else
				return true;
			fi;
		else 
			if not (IsBool(arg) or arg=0) then
				errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be a boolean or zero");
			else
				return true;
			fi;
		fi;
		
		return errorString;
	fi;
end);

InstallGlobalFunction(SRGroupsInfo,function(arg)
	local dir, fnam, G, list, listTemp, i, j, k, lastNonZero, argFunctions, argMinimums, out, max, maxArgLength, listGroups, booleanList;
	
	if IsEmpty(SRDegrees()) then
		Error("no data is available");
	fi;

	maxArgLength:=9;
	argFunctions:=["Degree","Depth/Level","Number","Projection","IsSubgroup","Size","MinimalGeneratingSet","Position/Index","IsAbelian"];
	lastNonZero:=0;
	
	for i in [1..maxArgLength] do
		if not IsBound(arg[i]) then
			arg[i]:=[0];
		elif not IsList(arg[i]) then
			arg[i]:=[arg[i]];
		fi;
		
		for j in [1..Length(arg[i])] do
			if not IsInt(arg[i][j]) then
				Error("input argument ",argFunctions[i],"=",arg[i][j]," in arg[",i,"] must be a non-negative integer");
			elif not arg[i][j]>=0 then
				Error("input argument ",argFunctions[i],"=",arg[i][j]," in arg[",i,"] must be a non-negative integer");
			fi;
		od;
		
		if 0 in arg[i] and Length(arg[i])>1 then
			Error("input argument ",argFunctions[i],"=",arg[i]," in arg[",i,"] cannot be zero with multiple entries");
		fi;
		
		if i<9 and arg[i][1]<>0 then
			lastNonZero:=i;
		fi;
	od;
	
	if arg[4][1]=0 then
		argMinimums:=[2,1,1,1,1,,1,1];
	else
		argMinimums:=[2,2,1,1,1,,1,1];
	fi;
	
	out:=CheckSRGroupsInputs(true,argMinimums,argFunctions,arg[1],arg[2]);
	if out[1]=true then
		argMinimums:=out[2];
		if arg[1][1]<>0 and arg[2][1]<>0 then
			if not arg[1]=out[3] then
				arg[1]:=out[3];
				Print("Restricting degrees to ",arg[1],"\n");
			fi;
			if not arg[2]=out[4] then
				arg[2]:=out[4];
				Print("Restricting levels to ",arg[2],"\n");
			fi;
		elif arg[1][1]<>0 and arg[2][1]=0 then
			if not arg[1]=out[3] then
				arg[1]:=out[3];
				Print("Restricting degrees to ",arg[1],"\n");
			fi;
		elif arg[1][1]=0 and arg[2][1]<>0 then
			if not arg[2]=out[3] then
				arg[2]:=out[3];
				Print("Restricting levels to ",arg[2],"\n");
			fi;
		fi;
	else
		Error(out[2]);
	fi;
	
	max:=CallFuncList(GetSRMaximums,arg);
	
	if lastNonZero>=3 then
		for i in [3..maxArgLength] do
			for j in [1..Length(arg[i])] do
				if i=3 or i=5 then
					out:=CheckSRGroupsInputs(i,arg[i][j],argMinimums,argFunctions,arg[1],arg[2],max[1]);
				elif i=4 then
					out:=CheckSRGroupsInputs(i,arg[i][j],argMinimums,argFunctions,arg[1],arg[2],max[2]);
				else
					out:=CheckSRGroupsInputs(i,arg[i][j],argMinimums,argFunctions,arg[1],arg[2]);
				fi;
				if IsString(out) then
					Error(out);
				fi;
			od;
		od;
	fi;

	dir:= DirectoriesPackageLibrary( "SRGroups", "data" );
	list:=[];
	if arg[1][1]<>0 and arg[2][1]<>0 then
		for i in [1..Length(arg[1])] do
			for j in [1..Length(arg[2])] do
				if SRGroupsAvailable(arg[1][i],arg[2][j]) then
					listTemp:=GetSRData(arg[1][i],arg[2][j]);
					Append(list,listTemp);
				fi;
			od;
		od;
	elif arg[1][1]<>0 and arg[2][1]=0 then
		for i in [1..Length(arg[1])] do
			for j in [argMinimums[2]..Length(SRLevels(arg[1][i]))] do
				listTemp:=GetSRData(arg[1][i],SRLevels(arg[1][i])[j]);
				Append(list,listTemp);
			od;
		od;
	elif arg[1][1]=0 and arg[2][1]<>0 then
		for i in [1..Length(SRDegrees())] do
			for j in [1..Length(arg[2])] do
				if SRGroupsAvailable(SRDegrees()[i],arg[2][j]) then
					listTemp:=GetSRData(SRDegrees()[i],arg[2][j]);
					Append(list,listTemp);
				fi;
			od;
		od;
	else
		for i in [1..Length(SRDegrees())] do
			for j in [argMinimums[2]..Length(SRLevels(SRDegrees()[i]))] do
				listTemp:=GetSRData(SRDegrees()[i],SRLevels(SRDegrees()[i])[j]);
				Append(list,listTemp);
			od;
		od;
	fi;
	
	if arg[9][1]<>0 then
		listTemp:=[];
		if arg[1][1]<>0 and arg[2][1]<>0 and arg[3][1]<>0 then
			Error("input arguments Number and IsAbelian are not compatible when a Degree and Depth have been selected");
		else
			for i in [1..Length(list)] do
				if IsAbelian(Group(list[i][1]))=arg[9][1] then
					Add(listTemp,list[i]);
				fi;
			od;
			list:=listTemp;
		fi;
	fi;
	
	if lastNonZero in [0,1,2] then
		G:=list;
		return G;
	fi;
	
	if arg[3][1]<>0 then
		listTemp:=[];
		for i in [1..Length(list)] do
			if EvalString(SplitString(SplitString(SplitString(list[i][2]," = ")[1],",")[3],")")[1]) in arg[3] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if lastNonZero=3 then
			G:=list;
			return G;
		fi;
	fi;
	
	if arg[4][1]<>0 and arg[3][1]=0 then
		listTemp:=[];
		for i in [1..Length(list)] do
			if EvalString(SplitString(SplitString(SplitString(list[i][3]," = ")[1],",")[3],")")[1]) in arg[4] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if lastNonZero=4 then
			G:=list;
			return G;
		fi;
	fi;
	
	if arg[5][1]<>0 and arg[3][1]=0 and (not (arg[1][1]=0 or arg[2][1]=0)) then
		listGroups:=[];
		listTemp:=[];
		for i in [1..Length(list)] do
			if EvalString(SplitString(SplitString(SplitString(list[i][2]," = ")[1],",")[3],")")[1]) in arg[5] then
				Add(listGroups,list[i]);
			fi;
		od;
		for i in [1..Length(list)] do
			booleanList:=ShallowCopy(listGroups);
			Apply(booleanList,H->(IsSubgroup(Group(H[1]),Group(list[i][1])) and Group(H[1])<>Group(list[i][1])));
			if true in booleanList then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if lastNonZero=5 then
			G:=list;
			return G;
		fi;
	fi;
	
	if arg[6][1]<>0 and arg[3][1]=0 then
		listTemp:=[];
		for i in [1..Length(list)] do
			if Size(Group(list[i][1])) in arg[6] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if lastNonZero=6 then
			G:=list;
			return G;
		fi;
	fi;
	
	if arg[7][1]<>0 and arg[3][1]=0  then
		listTemp:=[];
		for i in [1..Length(list)] do
			if Length(MinimalGeneratingSet(Group(list[i][1]))) in arg[7] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if lastNonZero=7 then
			G:=list;
			return G;
		fi;
	fi;
	
	if arg[8][1]<>0 then
		listTemp:=ShallowCopy(list);
		if Length(arg[8])=1 then
			Apply(listTemp,H->H[arg[8][1]]);
		elif Length(arg[8])=2 then
			Apply(listTemp,H->[H[arg[8][1]],H[arg[8][2]]]);
		elif Length(arg[8])=3 then
			Apply(listTemp,H->[H[arg[8][1]],H[arg[8][2]],H[arg[8][3]]]);
		elif Length(arg[8])=4 then
			Apply(listTemp,H->[H[arg[8][1]],H[arg[8][2]],H[arg[8][3]],H[arg[8][4]]]);
		fi;
		if Length(listTemp)=1 then
			listTemp:=listTemp[1];
		fi;
		list:=listTemp;
		if lastNonZero=8 then
			G:=list;
			return G;
		fi;
	fi;

	if IsBound(G) then
		return G;
	else
		Error("no method exists for those arguments; check if they are conflicting");
	fi;
end);