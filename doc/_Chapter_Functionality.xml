<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Functionality">
<Heading>Functionality</Heading>

<Section Label="Chapter_Functionality_Section_Methods">
<Heading>Methods</Heading>

<ManSection>
  <Filt Arg="G" Name="IsRegularRootedTreeGroup" Label="for IsPermGroup"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
 The argument of this category is any permutation group, <A>G</A>. Checks whether <A>G</A> is a regular rooted tree group.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="G" Name="RegularRootedTreeGroupDegree" Label="for IsRegularRootedTreeGroup"/>
 <Returns> The degree of <A>G</A>.
</Returns>
 <Description>
 The argument of this attribute is any regular rooted tree group, <A>G</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> RegularRootedTreeGroupDepth(AutT(2,3));
3
]]></Example>


<ManSection>
  <Attr Arg="G" Name="RegularRootedTreeGroupDepth" Label="for IsRegularRootedTreeGroup"/>
 <Returns> The depth of <A>G</A>.
</Returns>
 <Description>
 The argument of this attribute is any regular rooted tree group, <A>G</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> RegularRootedTreeGroupDegree(AutT(2,3));
2
]]></Example>


<ManSection>
  <Oper Arg="k,n,G" Name="RegularRootedTreeGroup" Label="for IsInt, IsInt, IsPermGroup"/>
 <Returns> The regular rooted tree group <A>G</A> as an object of the category <Ref Filt="IsRegularRootedTreeGroup"/>, with attributes <Ref Attr="RegularRootedTreeGroupDegree"/> and <Ref Attr="RegularRootedTreeGroupDepth"/>.
</Returns>
 <Description>
 The arguments of this operation are a regular rooted tree group, <A>G</A>, and its degree <A>k</A> and depth <A>n</A>.
 </Description>
</ManSection>


<ManSection>
  <Prop Arg="G" Name="IsSelfReplicating" Label="for IsRegularRootedTreeGroup"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
 The argument of this property is any regular rooted tree group, <A>G</A>. Tests whether <A>G</A> satisfies the self-replicating conditions.
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> IsSelfReplicating(AutT(2,3));
true
]]></Example>


<ManSection>
  <Prop Arg="G" Name="HasSufficientRigidAutomorphisms" Label="for IsRegularRootedTreeGroup"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
 The argument of this property is any regular rooted tree group, <A>G</A>. Tests whether <A>G</A> has sufficient rigid automorphisms.
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> HasSufficientRigidAutomorphisms(AutT(2,3));
true
]]></Example>


<ManSection>
  <Attr Arg="G" Name="ParentGroup" Label="for IsRegularRootedTreeGroup"/>
 <Returns> The image of <A>G</A> when projected onto the automorphism group of degree <A>k</A> and depth <A>n-1</A>.
 
 
</Returns>
 <Description>
 The argument of this attribute is any regular rooted tree group, <A>G</A>, of degree <A>k</A> and depth <A>n</A>.
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> G:=AutT(2,3); H:=AutT(2,2);
Group([ (1,2), (3,4), (5,6), (7,8), (1,3)(2,4), (5,7)(6,8), (1,5)(2,6)(3,7)(4,8) ])
Group([ (1,2), (3,4), (1,3)(2,4) ])
gap> ParentGroup(G);
Group([ (1,2), (1,3)(2,4), (3,4) ])
gap> H=last;
true
]]></Example>


<ManSection>
  <Attr Arg="G" Name="MaximalExtension" Label="for IsRegularRootedTreeGroup"/>
 <Returns> The maximal extension of <A>G</A>, <A>M(G)</A>, that is a subgroup of the automorphism group of degree <A>k</A> and depth <A>n+1</A>.
 
 
</Returns>
 <Description>
 The argument of this attribute is any regular rooted tree group, <A>G</A>, of degree <A>k</A> and depth <A>n</A>.
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> G:=AutT(2,3); H:=AutT(2,4);
Group([ (1,2), (3,4), (5,6), (7,8), (1,3)(2,4), (5,7)(6,8), (1,5)(2,6)(3,7)(4,8) ])
<permutation group of size 32768 with 15 generators>
gap> MaximalExtension(G);
<permutation group with 11 generators>
gap> H=last;
true
]]></Example>


<ManSection>
  <Attr Arg="G" Name="RepresentativeWithSufficientRigidAutomorphisms" Label="for IsRegularRootedTreeGroup"/>
 <Returns> A conjugate of <A>G</A> with sufficient rigid automorphisms.
 
 
</Returns>
 <Description>
 The argument of this attribute is any regular rooted tree group, <A>G</A>. 
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> 
]]></Example>


</Section>


<Section Label="Chapter_Functionality_Section_Library_Functions">
<Heading>Library Functions</Heading>

<ManSection>
  <Func Arg="k,n" Name="SRGroupsAvailable" />
 <Returns> Whether the self-replicating groups of degree, <A>k</A>, and depth, <A>n</A>, are available.
 
 
</Returns>
 <Description>
 The argument of this function is a degree, <A>k</A>, and a depth, <A>n</A>.
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> SRGroupsAvailable(2,3);
true
gap> SRGroupsAvailable(2,5);
true
gap> SRGroupsAvailable(5,2);
false
]]></Example>


<ManSection>
  <Func Arg="k,n" Name="NrSRGroups" />
 <Returns> The number of self-replicating groups of degree, <A>k</A>, and depth, <A>n</A>.
 
 
</Returns>
 <Description>
 The argument of this function is a degree, <A>k</A>, and a depth, <A>n</A>.
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> NrSRGroups(2,3);
15
gap> NrSRGroups(2,5);
2436
]]></Example>


<ManSection>
  <Func Arg="k,n,num" Name="SRGroup" />
 <Returns> The <A>num</A>th self-replicating group of degree <A>k</A> and depth <A>n</A> stored in the <Package>SRGroups</Package> library.
 
 
</Returns>
 <Description>
 The argument of this function is a degree, <A>k</A>, a depth, <A>n</A>, and a designated number of the stored self-replicating group, <A>num</A>.
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> SRGroup(2,3,1);
SRGroup(2,3,1)
gap> Size(last);
8
]]></Example>


<ManSection>
  <Func Arg="Input1, val1, Input2, val2, ..." Name="AllSRGroups" />
 <Returns> A list of self-replicating groups matching the input arguments as RegularRootedTreeGroup objects.
</Returns>
 <Description>
 Main library search function that acts analogously as the AllTransitiveGroups function from the <Package>transgrp</Package> library. Has several possible input arguments such as <A>Degree</A>, <A>Depth</A> (or <A>Level</A>), <A>Number</A>, <A>Projection</A>, <A>IsSubgroup</A>, <A>Size</A>, <A>NumberOfGenerators</A>, and <A>IsAbelian</A>. Order of the arguments do not matter. List inputs and singular inputs can be provided. The argument definitions are as follows:
 <A>Degree</A> (int > 1) := degree of tree
 <A>Depth</A>/<A>Level</A> (int > 0) := level of tree
 <A>Number</A> (int > 0) := self-replicating group number
 <A>Projection</A> (int > 0) := groups whose projected image are the group number on the level above
 <A>IsSubgroup</A> (int > 0) := groups that are a subgroup of the group number provided
 <A>Size</A> (int >= degree^depth or int > 1) := size of group
 <A>MinimalGeneratingSet</A> (int > 0) := size of the group's minimal generating set
 <A>IsAbelian</A> (boolean) := all groups that are abelian if true, and not abelian if false
 </Description>
</ManSection>


<Example><![CDATA[
gap> AllSRGroups(Degree, 2, Level, 4, IsAbelian, true);
[ SRGroup(2,4,2), SRGroup(2,4,9), SRGroup(2,4,12), SRGroup(2,4,14) ]
gap> AllSRGroups(Degree,[2..5],Depth,[2..5],IsSubgroup,[1..5],Projection,[1..3]);
Restricting degrees to [ 2, 3 ]
[ SRGroup(2,1,1), SRGroup(2,1,1), SRGroup(2,2,1), SRGroup(2,3,1),
  SRGroup(2,3,2), SRGroup(2,4,1), SRGroup(2,4,1), SRGroup(2,4,2),
  SRGroup(2,4,2), SRGroup(2,4,2), SRGroup(3,1,1), SRGroup(3,1,1),
  SRGroup(3,1,1), SRGroup(3,1,1) ]
]]></Example>


<ManSection>
  <Func Arg="Input1, val1, Input2, val2, ..." Name="AllSRGroupsInfo" />
 <Returns> Information about the self-replicating group(s) satisfying all of the provided input arguments in list form: [<A>Generators</A>, <A>Name</A>, <A>Parent Name</A>, <A>Children Name(s)</A>]. If the <A>Position</A> input is provided, only the corresponding index of this list is returned.
</Returns>
 <Description>
 Inputs work the same as the main library search function <Ref Func="AllSRGroups"/>, with one additional input: <A>Position</A> (or <A>Index</A>).
 Position/Index :=  (int in [1..4])
 </Description>
</ManSection>


<Example><![CDATA[
gap> AllSRGroupsInfo(Degree, 2, Depth, [2,3], IsAbelian, true);
[ [ [ (1,2)(3,4), (1,3,2,4) ], "SRGroup(2,2,1)", "SRGroup(2,1,1)",
      [ "SRGroup(2,3,1)", "SRGroup(2,3,2)" ] ],
  [ [ (1,2)(3,4), (1,3)(2,4) ], "SRGroup(2,2,2)", "SRGroup(2,1,1)",
      [ "SRGroup(2,3,3)", "SRGroup(2,3,4)", "SRGroup(2,3,5)",
          "SRGroup(2,3,6)" ] ],
  [ [ (1,5,4,8,2,6,3,7), (1,4,2,3)(5,8,6,7), (1,2)(3,4)(5,6)(7,8) ]
        , "SRGroup(2,3,1)", "SRGroup(2,2,1)",
      [ "SRGroup(2,4,1)", "SRGroup(2,4,2)" ] ],
  [
      [ (1,5,2,6)(3,7,4,8), (1,3)(2,4)(5,7)(6,8),
          (1,2)(3,4)(5,6)(7,8) ], "SRGroup(2,3,4)",
      "SRGroup(2,2,2)",
      [ "SRGroup(2,4,8)", "SRGroup(2,4,9)", "SRGroup(2,4,10)" ] ],
  [ [ (1,3)(2,4)(5,7)(6,8), (1,5)(2,6)(3,7)(4,8),
          (1,2)(3,4)(5,6)(7,8) ], "SRGroup(2,3,5)",
      "SRGroup(2,2,2)",
      [ "SRGroup(2,4,11)", "SRGroup(2,4,12)", "SRGroup(2,4,13)",
          "SRGroup(2,4,14)", "SRGroup(2,4,15)" ] ] ]
gap> AllSRGroupsInfo(Degree, 2, Level, [2,3], IsAbelian, true, Position, 1);
[ [ (1,2)(3,4), (1,3,2,4) ], [ (1,2)(3,4), (1,3)(2,4) ],
  [ (1,5,4,8,2,6,3,7), (1,4,2,3)(5,8,6,7), (1,2)(3,4)(5,6)(7,8) ],
  [ (1,5,2,6)(3,7,4,8), (1,3)(2,4)(5,7)(6,8), (1,2)(3,4)(5,6)(7,8) ],
  [ (1,3)(2,4)(5,7)(6,8), (1,5)(2,6)(3,7)(4,8), (1,2)(3,4)(5,6)(7,8) ] ]
]]></Example>


<ManSection>
  <Func Arg="k,n" Name="CheckSRProjections" />
 <Returns> Whether all of the self-replicating groups of degree <A>k</A> and level <A>n</A> project correctly to level <A>n-1</A>. This is mainly used after obtaining new data to check that it has been formatted correctly (see <Ref Func="SRGroupFile"/>).
</Returns>
 <Description>
 The arguments of this function are a degree, <A>k</A>, and a level, <A>n</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> CheckSRProjections(2,4);
All groups project correctly.
]]></Example>


<ManSection>
  <Func Arg="" Name="SRDegrees" />
 <Returns> All of the degrees currently stored in the <Package>SRGroups</Package> library.
</Returns>
 <Description>
 There are no inputs to this function.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SRDegrees();
[ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]
]]></Example>


<ManSection>
  <Func Arg="k" Name="SRLevels" />
 <Returns> All of the levels currently stored in the <Package>SRGroups</Package> library for an input RegularRootedTreeGroupDegree, <A>deg</A>.
</Returns>
 <Description>
 The input to this function is the degree of the regular rooted tree, <A>k</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SRLevels(2);
[ 1, 2, 3, 4 ]
]]></Example>


</Section>


<Section Label="Chapter_Functionality_Section_Package_Functions">
<Heading>Package Functions</Heading>

<ManSection>
  <Func Arg="k,n" Name="AutT" />
 <Returns> The regular rooted tree group <Math>\mathrm{Aut}(T_{k,n})</Math> as a permutation group of the <Math>k^{n}</Math> leaves of <Math>T_{k,n}</Math>.
 
</Returns>
 <Description>
 The arguments of this function are a degree <A>k</A> <Math>\in\mathbb{N}_{\ge 2}</Math> and a depth <A>n</A> <Math>\in\mathbb{N}</Math>.
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> G:=AutT(2,2);
Group([ (1,2), (3,4), (1,3)(2,4) ])
gap> Size(G);
8
]]></Example>


<ManSection>
  <Func Arg="k,n,aut,i" Name="BelowAction" />
 <Returns> The restriction of <A>aut</A> to the subtree below the level 1 vertex <A>i</A>, as an element of <F>AutT(</F><A>k</A>,<A>n-1</A><F>)</F>.
 
</Returns>
 <Description>
 The arguments of this function are a degree, <A>k</A> <Math>\in\mathbb{N}_{\ge 2}</Math>, a depth, <A>n</A> <Math>\in\mathbb{N}</Math>, an element of <F>AutT(</F><A>k</A>,<A>n</A><F>)</F>, <A>aut</A>, and a level 1 vertex, <A>i</A> <Math>\in\{1,\cdots,k\}</Math>.
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> BelowAction(2,2,(1,2)(3,4),2);
(1,2)
]]></Example>


<ManSection>
  <Func Arg="G, grouplist" Name="RemoveConjugates" />
 <Description>
 The arguments of this function are a group, <A>G</A>, and a list of groups, grouplist. For every group H1 in grouplist, this function removes all conjugate groups <Math>H2</Math> such that <Math>H2\in H1^G</Math>.
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> 
]]></Example>


<ManSection>
  <Func Arg="G" Name="ConjugacyClassRepsMaxSelfReplicatingSubgroups" />
 <Returns> A list containing conjugacy class representatives of all maximal self-replicating subgroups of <A>G</A>.
 
</Returns>
 <Description>
 The argument of this function is any regular rooted tree group, <A>G</A>
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> ConjugacyClassRepsMaxSelfReplicatingSubgroups(AutT(2,2));
[ Group([ (1,3)(2,4), (1,2)(3,4) ]), Group([ (1,3,2,4), (1,2)(3,4) ]) ]
]]></Example>


<ManSection>
  <Func Arg="G" Name="ConjugacyClassRepsSelfReplicatingSubgroupsWithConjugateProjection" />
 <Returns> A list containing conjugacy class representatives of all self-replicating subgroups of the maximal extension of <A>G</A>, <A>M(G)</A>.
 
</Returns>
 <Description>
 The argument of this function is any regular rooted tree group, <A>G</A>
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> ConjugacyClassRepsSelfReplicatingSubgroupsWithConjugateProjection(AutT(3,1));
[ Group([ (1,4,7)(2,5,8)(3,6,9), (1,4)(2,5)(3,6), (1,2,3), (1,2) ]),
  Group([ (4,7)(5,8)(6,9), (1,4,7)(2,5,8)(3,6,9), (5,6)(8,9), (2,3)
      (8,9), (7,9,8), (4,6,5), (1,3,2) ]),
  Group([ (2,3)(4,7)(5,9)(6,8), (1,4,7)(2,5,8)(3,6,9), (5,6)(8,9),
      (2,3)(8,9), (7,9,8), (4,6,5), (1,3,2) ]),
  Group([ (2,3)(5,6)(8,9), (4,7)(5,8)(6,9), (1,4,7)(2,5,8)(3,6,9),
      (7,9,8), (4,6,5), (1,3,2) ]),
  Group([ (1,7)(2,8)(3,9)(5,6), (1,7,4)(2,9,5)(3,8,6), (1,2,3),
      (7,8,9), (4,6,5)(7,8,9) ]),
  Group([ (2,3)(4,7)(5,8)(6,9), (4,6,5)(7,9,8), (1,4,7)(2,5,9)
      (3,6,8), (1,2,3)(4,5,6)(7,9,8) ]),
  Group([ (2,3)(4,7)(5,8)(6,9), (1,7,6,2,9,4,3,8,5), (1,2,3)
      (4,6,5), (1,2,3)(4,5,6)(7,9,8) ]),
  Group([ (2,3)(4,7)(5,8)(6,9), (1,6,7,3,5,8,2,4,9), (1,3,2)(4,6,5)
      (7,8,9) ]),
  Group([ (2,3)(4,7)(5,8)(6,9), (1,7,4)(2,9,5)(3,8,6), (1,2,3)
      (4,5,6)(7,9,8) ]),
  Group([ (1,4)(2,5)(3,6), (1,7,4)(2,8,5)(3,9,6), (2,3)(5,6)(8,9),
      (1,2,3)(4,5,6)(7,8,9), (4,5,6)(7,9,8) ]),
  Group([ (2,3)(5,6)(8,9), (4,7)(5,8)(6,9), (1,4,7)(2,5,8)(3,6,9),
      (1,3,2)(4,6,5)(7,9,8) ]) ]
]]></Example>


<ManSection>
  <Func Arg="k" Name="SRGroupFile" />
 <Description>
 The arguments of this function are a degree, <A>k</A>, or <A>0</A>. If the argument is non-zero, this function creates the file containing all self-replicating groups of the regular rooted k-tree at the lowest level not stored in the <Package>SRGroups</Package> library. If the argument is <A>0</A>, this function creates the file containing all self-replicating groups of the regular rooted tree at the level 1 for the lowest degree not stored in the <Package>SRGroups</Package> library. The file naming convention is "sr_k_n.grp", and they are stored in the "data" folder of the <Package>SRGroups</Package> package. Level 1 groups are calculated using the <Package>transgrp</Package> library. If the argument is non-zero and there is a gap between files (i.e. if "sr_k_n.grp" and "sr_k_n+2.grp" exists, but "sr_k_n+1.grp" does not exist), then this function creates the files in this gap.
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> SRGroupFile(2);
You have requested to make group files for degree 2.
Creating level 3 file.
Evaluating groups extending from:
SRGroup(2,2,1)  (1/3)
SRGroup(2,2,2)  (2/3)
SRGroup(2,2,3)  (3/3)
SRGroup(2,2,4)  (4/3)
Formatting file sr_2_3.grp now.
Reordering individual files.
Done.
gap> SRGroupFile(0);
Creating degree 5 file on level 1.
Done.
gap> SRGroupFile(2);
You have requested to make group files for degree 2.
Gap found; missing file from level 2. Creating the missing file now.
Creating files:
sr_2_2.grp
Done.
]]></Example>


<ManSection>
  <Func Arg="arg" Name="ExtendSRGroup" />
 <Description>
 The arguments of this function are: arg[1]: degree of tree (int > 1), <A>k</A>, arg[2]: highest level of tree where the file "sr_k_n.grp" exists (int > 1), <A>n</A>, (arg[3],arg[4],...): sequence of group numbers to extend from using the files "temp_k_n_arg[3]_arg[4]_...arg[Length(arg)-1].grp". This function creates the file of the group number arg[Length(arg)] stored in the file "temp_k_n_arg[3]_arg[4]_...arg[Length(arg)-1].grp", and saves it as "temp_k_n_arg[3]_arg[4]_...arg[Length(arg)].grp".
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="k,n" Name="CombineSRFiles" />
 <Description>
 The arguments of this function are a degree, <A>k</A>, and a level, <A>n</A>, of a regular rooted tree, <A>n-1</A> is the highest level stored as the file "sr_k_n-1.grp" in the <Package>SRGroups</Package> library, and all of the files "temp_k_n-1_i_proj.grp" for every SRGroup(k,n-1,i) are stored in the "data/temp_k_n" folder of the <Package>SRGroups</Package> library. This function combines each of the "temp_k_n-1_i_proj.grp" files into the complete "temp_k_n.grp" file to be used by the <Ref Func="SRGroupFile"/> function.
<P/>
 </Description>
</ManSection>


</Section>


</Chapter>

