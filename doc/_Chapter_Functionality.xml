<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Functionality">
<Heading>Functionality</Heading>

<Section Label="Chapter_Functionality_Section_Methods">
<Heading>Methods</Heading>

<ManSection>
  <Filt Arg="arg" Name="IsRegularRootedTreeGroup" Label="for IsPermGroup"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
 Checks whether the input group is a regular-rooted tree group.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="arg1,arg2,arg3" Name="RegularRootedTreeGroup" Label="for IsInt, IsInt, IsPermGroup"/>
 <Description>
 Creates a regular-rooted tree group with attributes <A>RegularRootedTreeGroupDegree</A> and <A>RegularRootedTreeGroupDepth</A>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Functionality_Section_Functions">
<Heading>Functions</Heading>

<ManSection>
  <Func Arg="arg" Name="AllSRGroups" />
 <Description>
 Main library search function. Has several possible input arguments such as <A>Degree</A>, <A>Level</A> (or <A>Depth</A>), <A>Number</A>, <A>Projection</A>, <A>Subgroup</A>, <A>Size</A>, <A>NumberOfGenerators</A>, and <A>IsAbelian</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> AllSRGroups(Degree, 2, Level, 4, IsAbelian, true);
[ SRGroup(2,4,2), SRGroup(2,4,9), SRGroup(2,4,12), SRGroup(2,4,14) ]
gap> Size(last[1]);
16
gap> AllSRGroups(Degree,2,Level,4,NumberOfGenerators,4);
[ SRGroup(2,4,11), SRGroup(2,4,12), SRGroup(2,4,16), SRGroup(2,4,20), SRGroup(2,4,23), SRGroup(2,4,24),
 SRGroup(2,4,25), SRGroup(2,4,26), SRGroup(2,4,40), SRGroup(2,4,43), SRGroup(2,4,46), SRGroup(2,4,47),
 SRGroup(2,4,50), SRGroup(2,4,66), SRGroup(2,4,70), SRGroup(2,4,71), SRGroup(2,4,72), SRGroup(2,4,73),
 SRGroup(2,4,74), SRGroup(2,4,75), SRGroup(2,4,76), SRGroup(2,4,84), SRGroup(2,4,90), SRGroup(2,4,91),
 SRGroup(2,4,93), SRGroup(2,4,95), SRGroup(2,4,97), SRGroup(2,4,102), SRGroup(2,4,108) ]
]]></Example>


<ManSection>
  <Func Arg="arg" Name="SRGroupsInfo" />
 <Description>
   Insert documentation for your function here
 </Description>
</ManSection>


<ManSection>
  <Func Arg="arg" Name="AllSRGroupsInfo" />
 <Description>
 Works the same as the main library search function <A>AllSRGroups</A>, except returns useful information about the group(s) in list form: [<A>Generators</A>, <A>Name</A>, <A>Parent Name</A>, <A>Children Names</A>].
 </Description>
</ManSection>


<Example><![CDATA[
gap> AllSRGroupsInfo(Degree, 2, Level, 3, IsAbelian, true);
[ [ [ (1,5,4,8,2,6,3,7), (1,4,2,3)(5,8,6,7), (1,2)(3,4)(5,6)(7,8) ], "SRGroup(2,3,1)", "SRGroup(2,2,1)", [ "SRGroup(2,4,1)", "SRGroup(2,4,2)" ] ],
[ [ (1,5,2,6)(3,7,4,8), (1,3)(2,4)(5,7)(6,8), (1,2)(3,4)(5,6)(7,8) ], "SRGroup(2,3,4)", "SRGroup(2,2,2)", [ "SRGroup(2,4,8)", "SRGroup(2,4,9)", "SRGroup(2,4,10)" ] ], 
[ [ (1,3)(2,4)(5,7)(6,8), (1,5)(2,6)(3,7)(4,8), (1,2)(3,4)(5,6)(7,8) ], "SRGroup(2,3,5)", "SRGroup(2,2,2)", [ "SRGroup(2,4,11)", "SRGroup(2,4,12)", "SRGroup(2,4,13)", "SRGroup(2,4,14)", "SRGroup(2,4,15)" ] ] ]
]]></Example>


<ManSection>
  <Func Arg="arg" Name="CheckSRProjections" />
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="arg" Name="StringVariables" />
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="arg" Name="UnbindVariables" />
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="arg" Name="SRDegrees" />
 <Description>
 Returns all of the degrees currently stored in the SRGroups library.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SRDegrees();
[ 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
]]></Example>


<ManSection>
  <Func Arg="arg" Name="SRLevels" />
 <Description>
 Returns all of the levels currently stored in the SRGroups library for an input RegularRootedTreeGroupDegree, <A>deg</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SRLevels(2);
[ 1, 2, 3, 4 ]
]]></Example>


<ManSection>
  <Func Arg="k,n" Name="AutT" />
 <Returns> the regular rooted tree group <Math>\mathrm{Aut}(T_{k,n})</Math> as a permutation group of the <Math>k^{n}</Math> leaves of <Math>T_{k,n}</Math>.
 
</Returns>
 <Description>
 The arguments of this method are a degree <A>k</A> <Math>\in\mathbb{N}_{\ge 2}</Math> and a depth <A>n</A> <Math>\in\mathbb{N}</Math>.
<P/>
 </Description>
</ManSection>


<P/>
<Example><![CDATA[
gap> G:=AutT(2,2);
Group([ (1,2), (3,4), (1,3)(2,4) ])
gap> Size(G);
8
]]></Example>


</Section>


</Chapter>

